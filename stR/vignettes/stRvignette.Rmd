---
title: "Package stR"
author: "Alex Dokumentov"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Package stR}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

This vignette describes functionality and provides examples of how to use package stR.
stR implements method STR, and STR comes as an abbreviation for Seasonal-Trend decomposition by Regression and capital R comes from from R, the name for a popular statistical software. The name is also reminiscent of STL, the method which inspired me to create STR.

## Introducation

There are many packages and methods which work with seasonal data. For example the oldest method for decomposition -- classical additive decomposition -- is implemented in package <code>stats</code>. Here is an example:
```{r, fig.show='hold', fig.width = 7, fig.height = 4.5, cache=TRUE}
m <- decompose(co2)
plot(m)
```
The method attempts to split the data into trend, seasonal and random components.

Another method is STL. It is implemented in packages <code>stats</code> and <code>stlplus</code>. Here is an example:
```{r, fig.show='hold', fig.width = 7, fig.height = 4.5}
plot(stl(log(co2), s.window = "per", t.window = 30))
```

Other packages which implement various versions of seasonal decomposition and seasonal adjustment include: <code>forecast</code>, <code>x12</code>, <code>seasonal</code>, <code>season</code>, <code>seas</code>, <code>deseasonalize</code>.

A few more examples are below:
```{r, results='hide', message=FALSE, echo=FALSE, warning=FALSE, cache=TRUE, autodep=FALSE}
require(forecast)
require(seasonal)
```
```{r, fig.show='hold', fig.width = 7, fig.height = 4.5, cache=TRUE, autodep=FALSE}
require(forecast)
plot(tbats(co2))
```

```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
require(seasonal)
co2.fit <- seas(co2)
plot(co2.fit, trend = T)
```


After looking at the above examples the reader might have a very legitimate question: Why do we need another method for seasonal decomposition?

A simple answer is that

  1. the new methid has a reach set of features (and allows to implement more features) and
  2. the method also has theoretical background, which satisfies me more than other methods.

This vignette provides more details on the first claim.

## Getting started

In this section we will continue working with <code>co2</code> dataset.
First of all we can notice that <code>co2</code> is of class <code>ts</code>:

```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
class(co2)
```

Therefore we can use <code>AutoSTR</code> functon directly, and the call will be automatically routed to <code>AutoSTR.ts</code>, the dedicated function to work with <code>ts</code> class:

```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
# co2.fit = AutoSTR(co2)
# plot(co2.fit)
```

You can notice that it works longer that any other above mentioned methods. It happens partially because the <code>AutoSTR</code> function tries to estimate the best parameters of the corresponding STR model. If the parameters are known, the execution is much faster:

```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
# co2.fit = STR(co2, lambdas = list(c(2,0,0),(1,2,2)))
# plot(co2.fit)
```


## More complex examples

Bla-bla...

## Even more examples

Even more bla-bla-bla...
