---
title: "Package stR"
author: "Alexander Dokumentov"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Package stR}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

This vignette describes some functionality and provides a few examples of how to use package stR.
stR implements method STR, and STR comes as an abbreviation for Seasonal-Trend decomposition by Regression and capital R comes from from R, the name for a popular statistical software. The name is also reminiscent of STL, the method which inspired me to start working on STR.


## Introducation

There are many packages and methods which work with seasonal data. For example the oldest method for decomposition -- classical additive decomposition -- is implemented in package <code>stats</code>. Here is an example:
```{r, fig.show='hold', fig.width = 7, fig.height = 4.5, cache=TRUE}
m <- decompose(co2)
plot(m)
```
The method attempts to split the data into trend, seasonal and random components.

Another method is STL. It is implemented in packages <code>stats</code> and <code>stlplus</code>. Here is an example:
```{r, fig.show='hold', fig.width = 7, fig.height = 4.5}
plot(stl(log(co2), s.window = "per", t.window = 30))
```

Other R packages which implement various versions of seasonal decomposition and seasonal adjustment include: <code>forecast</code>, <code>x12</code>, <code>seasonal</code>, <code>season</code>, <code>seas</code>, <code>deseasonalize</code>.

A few more examples are below:
```{r, results='hide', message=FALSE, echo=FALSE, warning=FALSE, cache=TRUE, autodep=FALSE}
require(forecast)
require(seasonal)
```
```{r, fig.show='hold', fig.width = 7, fig.height = 4.5, cache=TRUE, autodep=FALSE}
require(forecast)
plot(tbats(co2))
```

```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
require(seasonal)
co2.fit <- seas(co2)
plot(co2.fit, trend = T)
```


After looking at the above examples a reader might ask a very legitimate question: Why someone needs another method of seasonal decomposition?

A short answer is that

  1. the new method has a rich set of features (and allows to implement more features) and
  2. the method also has theoretical background, which might satisfy more than other methods.

This vignette provides more details on the first claim.


## Getting started

In this section we will continue working with <code>co2</code> dataset.
Since <code>co2</code> is of class <code>ts</code>

```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
class(co2)
```

we can use <code>AutoSTR</code> function (<code>AutoSTR.ts</code>):

```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE, echo=TRUE, warning=FALSE, results='hide'}
co2.fit = AutoSTR(co2)
```
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
plot(co2.fit)
```

The execution takes longer than for any of the above mentioned methods. It happens because the <code>AutoSTR</code> function estimates parameters of the STR model.


## Example with multiple seasonality

Dataset <code>taylor</code> from package <code>forecast</code> provides us with half-hourly electricity demand in England and Wales. It exhibits (at least) two seasonalities -- daily and weekly. They can bee observed in the subset (4 weeks) of the data below:
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
taylor.msts <- msts(log(head(as.vector(taylor), 336*4)),
                    seasonal.periods=c(48,336),
                    ts.frequency=48*7*52.25,
                    start=2000+22/52)
plot(taylor.msts, ylab = "Electricity demand")
```
Since the data in half hour granularity, the daily seasonality is 48 observations and weekly is 336.

The data is <code>msts</code> class time series, and <code>AutoSTR</code> function (<code>AutoSTR.msts</code>) can be used to decompose the data:
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE, echo=TRUE, warning=FALSE, results='hide'}
taylor.fit = AutoSTR(taylor.msts, gapCV = 48, reltol = 0.001, confidence = 0.95)
```
```{r, fig.show='hold', fig.width = 7, fig.height = 4.5, cache=TRUE, autodep=FALSE}
plot(taylor.fit)
```
The supplied parameters are:

* <code>gapCV = 48</code> -- gaps of 48 observations are used for cross validation
* <code>reltol = 0.001</code> -- this parameter is passed directly to <code>optim</code> function, it controls how well (and for how long) the model parameters are optimized
* <code>confidence = 0.95</code> -- 95% confidence intervals are calculated (with assumptions, which are not always true: errors are uncorrelated, model parameters are estimated exactly)


## Tunung STR decomposition

This example shows how to tune STR decomposition. STR is a flexible method, which can be adjusted to data various ways. Thus the interface is rather complex. This is the price for flexibility of the method.

I will use dataset <code>grocery</code> which contains monthly data of supermarkets and grocery stores turnover in New South Wales:
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
plot(grocery, ylab = "NSW Grocery Turnover, $ 10^6")
```
We will use log transformation to stabilize seasonal variance in the data:
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
logGr = log(grocery)
plot(logGr, ylab = "NSW Grocery Turnover, log scale")
```

At the next step we will define trend and seasonal structures.
Trend does not have seasonality, therefore its seasonal structure contains only a single knot: <code>c(1,0)</code>. Here knot is defined as a pair of numbers and it means that both of them refer to the same point. <code>segments</code> component will be better described below.
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
trendSeasonalStructure = list(
  segments = list(c(0,1)),
  sKnots = list(c(1,0)))
```

Seasonal structure of our data is defined in <code>seasonalStructure</code> variable. Here <code>segments</code> contains one pair of numbers <code>c(0,12)</code> which defines ends of a "segment" of knots, while <code>sKnots</code> defines seasonal knots from 1 to 12 (months). The last knot <code>c(0,12)</code> also defines that ends of the segment <code>c(0,12)</code> are connected and 0 and 12 represent the same knot (month).
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
seasonalStructure = list(
  segments = list(c(0,12)),
  sKnots = list(1,2,3,4,5,6,7,8,9,10,11,c(12,0)))
```

Variable <code>seasons</code> contain months corresponding to every data point.
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
seasons = as.vector(cycle(logGr))
```

Since trend does not have seasons (the seasonal structure for the trend has only one possible season) the trend seasons are all ones.
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
trendSeasons = rep(1, length(logGr))
```

<code>times</code> vector contains times corresponding to data points
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
times = as.vector(time(logGr))
```

<code>data</code> vector contains observations (in this case log turnover)
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
data = as.vector(logGr)
```

<code>trendTimeKnots</code> vector contains times where time knots for the trend will be positioned.
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
trendTimeKnots = seq(
  from = first(times),
  to = last(times),
  length.out = 175)
```

<code>seasonTimeKnots</code> vector contains times where time knots for the seasonal component will be positioned.
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
seasonTimeKnots = seq(
  from = first(times),
  to = last(times),
  length.out = 15)
```

This variable is relevant to regressors. In this case it is initialized with ones.
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
trendData = rep(1, length(logGr))
```
This variable is also relevant to regressors. In this case it is initialized with ones.
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
seasonData = rep(1, length(logGr))
```

The complete <code>trend</code> structure contains all components relevant to the trend.
Component <code>lambdas</code> is always a vector with three elements. Trend, since it does not have seasonality, has only the first element different from zero. This element defines smoothness of the trend at starting point of the optimization procedure.
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
trend = list(
  name = "Trend",
  data = trendData,
  times = times,
  seasons = trendSeasons,
  timeKnots = trendTimeKnots,
  seasonalStructure = trendSeasonalStructure,
  lambdas = c(0.5,0,0))
```

The complete <code>season</code> structure contains all components relevant to the trend. Component <code>lambdas</code> is a vector with three elements. The elements define smoothness of the seasonal component at starting point of the optimization procedure.

I need to refer to the corresponding article for STR method and remind that according to STR approach the seasonal component has two-dimensional structure. In this case it has topology of a tube. One dimensional seasonal component is a subset of data at that two-dimensional structure and lays on a spiral path curling around and forward the tube.

The first element of the vector defines smoothness in time dimension on the above mentioned tube. The second component defines smoothness in seasonal dimension. And the third component defines smoothness and both dimensions (by restricting partial discrete derivative in both directions).

The last two zeros in <code>lambdas</code> component mean that those two components will not be optimized (and effectively two dimensional structure of the seasonal component will not be used).
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
season = list(
  name = "Yearly seasonality",
  data = seasonData,
  times = times,
  seasons = seasons,
  timeKnots = seasonTimeKnots,
  seasonalStructure = seasonalStructure,
  lambdas = c(10,0,0))
```

All components of STR decomposition are considered to be predictors. For example trend is a predictor with no seasonality and independent variable which is constant (and equal to one). The seasonal component is a predictor with seasonality and independent variable which is also constant.
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
predictors = list(trend, season)
```

To calculate STR decomposition we supply data points, predictors, required confidence intervals, gap to be provided in data to perform cross validation and reltol parameter which was described earlier.
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE, echo=TRUE, warning=FALSE, results='hide'}
gr.fit = AutoSTR(data, predictors, confidence = 0.95, gap = 1, reltol = 0.00001)
```

In <code>plot</code> function <code>forecastScreens = NULL</code> means that fit/forecast will not be displayed.
```{r, fig.show='hold', fig.width = 7, fig.height = 4, cache=TRUE, autodep=FALSE}
plot(gr.fit, xTime = times, forecastScreens = NULL)
```

If we decide to use two-dimensional structure for the seasonal component we need to redefine <code>lambdas</code>:
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE, echo=TRUE, warning=FALSE, results='hide'}
season = list(
  name = "Yearly seasonality",
  data = seasonData,
  times = times,
  seasons = seasons,
  timeKnots = seasonTimeKnots,
  seasonalStructure = seasonalStructure,
  lambdas = c(1,1,1))
predictors = list(trend, season)
gr.fit = AutoSTR(data, predictors, confidence = 0.95, gap = 1, reltol = 0.00001)
```
```{r, fig.show='hold', fig.width = 7, fig.height = 4, cache=TRUE, autodep=FALSE}
plot(gr.fit, xTime = times, forecastScreens = NULL)
```

It provides a better fit and potentially more insightful decomposition.


## Robust STR decomposition

Let us create a time series with two "spikes"
```{r, fig.show='hold', fig.width = 7, fig.height = 4, cache=TRUE, autodep=FALSE}
outl = rep(0,length(grocery))
outl[14] = 900
outl[113] = -700
tsOutl = ts(outl, start = c(2000,1), frequency = 12)
```
and combine it with <code>grocery</code> time series
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE}
logGrOutl = log(grocery + tsOutl)
plot(logGrOutl, ylab = "Log turnover with outliers")
```

If we decompuse this time series with STR, the outliers will spoil the decomposition
```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE, echo=TRUE, warning=FALSE, results='hide'}
trendSeasonalStructure = list(segments = list(c(0,1)),
                              sKnots = list(c(1,0)))
seasonalStructure = list(segments = list(c(0,12)),
                         sKnots  = list(1,2,3,4,5,6,7,8,9,10,11,c(12,0)))
seasons = as.vector(cycle(logGrOutl))
trendSeasons = rep(1, length(logGrOutl))
times = as.vector(time(logGrOutl))
data = as.vector(logGrOutl)
timeKnots = times
trendData = rep(1, length(logGrOutl))
seasonData = rep(1, length(logGrOutl))
trend = list(data = trendData,
             times = times,
             seasons = trendSeasons,
             timeKnots = timeKnots,
             seasonalStructure = trendSeasonalStructure,
             lambdas = c(0.1,0,0))
season = list(data = seasonData,
              times = times,
              seasons = seasons,
              timeKnots = timeKnots,
              seasonalStructure = seasonalStructure,
              lambdas = c(10,0,0))
predictors = list(trend, season)

fit.str = AutoSTR(as.vector(logGrOutl), predictors, confidence = 0.95, gapCV = 1, reltol = 0.001)
```

```{r, fig.show='hold', fig.width = 7, fig.height = 4, cache=TRUE, autodep=FALSE}
plot(fit.str, xTime = times, forecastScreens = NULL)
```

```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE, echo=TRUE, warning=FALSE, results='hide'}
fit.rstr = AutoRSTR(as.vector(logGrOutl), predictors, confidence = 0.95, gapCV = 1, reltol = 0.001, nMCIter = 200)
```

```{r, fig.show='hold', fig.width = 7, fig.height = 4, cache=TRUE, autodep=FALSE}
plot(fit.rstr, xTime = times, forecastScreens = NULL)
```


## Another example with multiple seasonality 

Here topology for daily and weekly seasonality is "stripe". It is made different from tube because data provided from 7:00 am till 9:05 pm and Monday to Friday and there is no data from 9:05 pm till 7:00 am or on weekends. Thus we can assume there is no much "relation" between latest evening data point and next day morning data point for daily seasonality. Similarly it can be assumend that there is no much "relation" between Friday and Monday data points for weekly seasonality.

```{r, fig.show='hold', fig.width = 7, fig.height = 3, cache=TRUE, autodep=FALSE, echo=TRUE, warning=FALSE, results='hide'}
trendSeasonalStructure = list(segments = list(c(0,1)),
                              sKnots = list(c(1,0)))
trendSeasons = rep(1, length(calls))
times = as.vector(time(calls))
timeKnots = seq(min(times), max(times), length.out=25)

sKnotsDays = as.list(seq(1, 169, length.out = 169))
seasonalStructureDays = list(segments = list(c(1, 169)),
                             sKnots = sKnotsDays)
seasonsDays = seq_along(calls) %% 169 + 1

sKnotsWeeks = as.list(seq(0,169*5, length.out=13*5))
seasonalStructureWeeks = list(segments = list(c(0, 169*5)),
                              sKnots = sKnotsWeeks)
seasonsWeeks = seq_along(calls) %% (169*5) + 1

data = as.vector(calls)
trendData = rep(1, length(calls))
seasonData = rep(1, length(calls))

trend = list(data = trendData, times = times, seasons = trendSeasons,
             timeKnots = timeKnots,
             seasonalStructure = trendSeasonalStructure,
             lambdas = c(0.02, 0, 0))

seasonDays = list(data = seasonData, times = times, seasons = seasonsDays,
                  timeKnots = seq(min(times), max(times), length.out=25),
                  seasonalStructure = seasonalStructureDays,
                  lambdas = c(0, 11, 30))

seasonWeeks = list(data = seasonData, times = times, seasons = seasonsWeeks,
                   timeKnots = seq(min(times), max(times), length.out=25),
                   seasonalStructure = seasonalStructureWeeks,
                   lambdas = c(30, 500, 0.02))

predictors = list(trend, seasonDays, seasonWeeks)

calls.fit = AutoSTR(data = data,
               predictors = predictors,
               confidence = 0.95,
               reltol = 0.003,
               nFold = 4,
               gap = 169)
```

```{r, fig.show='hold', fig.width = 7, fig.height = 4, cache=TRUE, autodep=FALSE}
plot(calls.fit,
     xTime = as.Date("2003-03-03") +
       ((seq_along(data)-1)/169) +
       (((seq_along(data)-1)/169) / 5)*2,
     forecastScreens = NULL)
```


## Complex example

Even more bla-bla-bla...
